---
layout:     page
title:      Minimax Chess Bot in Python, SlateChess
summary:    A minimax chess bot in Python, using Alpha Beta Pruning, Move Ordering, Quescience Search. Written on my iPhone.
categories: jekyll pixyll
---

When I started this project on holiday, all I had was my phone, and so using the app 
Pythonista I pushed on. This constraint posed a _unique_ challenge but one that I was happy
to undertake! This chess program is played in the console, and moves are represented as a start and end space:
such as __a2 -> b3__.

![Chess Console One](/images/console_chess_one.png)
![Chess Console Two](/images/console_chess_two.png)

I started this project by reading old blog posts (have lost the link since) from which I 
learned about not just the minimax technique, but also extensions to improve it's 
speeed or quality. Such as bitboards, alpha-beta pruning, move ordering and quescience search.

I decided to implement the core minimax, in the form of negamax first. I was
then able to extend my solution with different features afterwards.

The __ChessGame.py__ program is the entry point for the code, it then utilises 
the negamax function in __Negamax.py__ to decide which move is best. And __Negamax.py__ 
uses functions in __ChessBoard.py__ to represent the chess board, movie pieces and get a static evaluation.

## ChessGame.py

__ChessGame.py__ provides the overall game loop: Move the AI player, display, move the human player, display. You are able to pass in a string which represents the starting board
so you can continue a game that wasn't finished.

{% highlight python lineanchors %}

Display(board)
while move != "STOP":

        #Decide on move
	minimaxMove = negamax(board, maxDepth, 1 , 2, -10000, 10000)  
        #Make move
	board = Move(board, minimaxMove[0], minimaxMove[1])

        #Display the new board
	Display(board)
	
	#Get player input
	inpList = input().split()
    
        . . .
        #Make move
	board = Move(board, move[0], move[1])

        #Display the new board
	Display(board)

{% endhighlight %}

## Negamax.py

__Negamax.py__ provides the minimax algorithm. It follows the classic structure for such implementations.
One interesting change was that there also had to be checkmate detection. So the __GenerateLegalMoves()__
indicates if the game is in such a situation by returning "C".

{% highlight python lineanchors %}

def negamax(board, depth, side, opposite):
    global count, maxDepth
    moves = GenerateLegalMoves(board, side, opposite, depth, maxDepth)
    if moves == "C":
        return "C"
    if depth == 0:
        count += 1
        return EvaluateNegamax(board, side)
    max = -10000000000
    maxMove = ()
    for i in range(len(moves[0])):
        score = negamax(Move(board, moves[0][i], moves[1][i]), depth-1, opposite, side) 
        if score == "C":
            continue
        score = -score
        if score > max:
            max = score
            maxMove = (moves[0][i], moves[1][i]) 
    if depth == maxDepth:
        print(count)
        print(maxMove, max)
        return maxMove
    if max == -10000000000:
        return -1000
    return max

{% endhighlight %}


## ChessBoard.py

__ChessBoard.py__ provides the actual functionality and rules of a chess board. It is able to generate the possible moves for each piece
given the current board. Here is the move generator for knights, __KnightMoves()__: 

{% highlight python lineanchors %}
	
def KnightMoves(board, x, y, side, opposite):
	KnightAdjustments = [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(1,-2),(2,-1)]
	Moves = []
	if side == 1:
		for adjust in KnightAdjustments:
			move = (adjust[0] + x, adjust[1] + y)
			moveEnd = ValueOf(board, move[0], move[1], side)
			if moveEnd == 0 or moveEnd > 6:
				Moves.append(move)
		return Moves
	elif side == 2:
		for adjust in KnightAdjustments:
			move = (adjust[0] + x, adjust[1] + y)
			moveEnd = ValueOf(board, move[0], move[1], side)
			if moveEnd <= 6:
				Moves.append(move)
		return Moves
{% endhighlight %}

It also provides static evaluation for the current state of the board. This value represents how advantageous 
the current board is for a given side. Here is the function __EvaluateNegamax.py__.

{% highlight python lineanchors %}


def EvaluateNegamax(board, side):
	global wBoard
	Material = [0,1,5,3,3,9,0,-1,-5,-3,-3,-9,0]
	MaterialPosition = [0,3,3,2.75,4,0,0,-3,-3,-2.75,-4,0,0]
	Value = 0
	addition = 0
	for y in range(8):
		for x in range(8):
			piece = board[y][x]
			Value += Material[piece]
			Value += MaterialPosition[piece] * wBoard[y][x] / 100
	if side == 1:
		return Value
	elif side == 2:
		return -Value

{% endhighlight %}

## Enhancements

Implementing __alpha-beta__ pruning was easy enough, as it is well documented and is only a small change from the
basic negamax formula. Although testing it to ensure it worked properly took a lot of time.

Implementing __quescience search__, which, if the minimax stops at a move with a capture, will look further
down the line until their is some "quiet" position with no capture. Was a challenge as it involved rewriting much of the already existing negamax code,
to allow this possible final evaluation step.

This bot was able to beat one of my friends a few times, but lost to a more skilled player.
Find [the link to the github here.](https://github.com/jc10101010/SlateChess)

### Future Plans: 
  * Allow for en passant moves
  * Investigate monte carlo tree search algorithm
